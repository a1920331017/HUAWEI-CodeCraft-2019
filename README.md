# HUAWEI-CodeCraft-2019
2019届华为软件精英挑战赛——Run the world（初赛判题器-可巧妙判别死锁）
在这里手动@我的逻辑思维强大的队友@a1920331017，这是他的github账号

1、本代码为2019届华为软件精英挑战赛“智能世界.纵横”初赛题目的汽车调度判题器。我们采取的方法是将各条道路的长度与车道数处理成一个二维矩阵，由于车身长度为1则矩阵每个位置的初始值设为0，代表道路在改点处无车，否则将该位置元素设置为车辆牌号，因此某一时刻道路信息为若干矩阵（道路，包含双向）的状态。

2、每一秒钟的调度都将按照题目要求的优先级要求进行调度，将车分为两大类：① 车辆下一秒钟不能通过路口②车辆下一秒钟能够通过路口

3、根据上面两大类，在对该车前面旁边或者下一条驶入的的道路信息进行检索，看能否前进，能前进则更新道路矩阵，否则看情况调度前方车辆（此处用函数递归调用实现），调度函数为地图类中的concrol_car()方法实现，每调用一次，代表对某辆车进行了调度。

4、具体细节不再描述，下面主要说明死锁情况，若调度某辆车时，在各种情况下，阻碍车辆的状态为等待状态，则出现死锁情况，此时，用函数返回值 return 'death_lock' 来实现函数调用结束，能够同时跳出循环部分和本函数剩余代码部分。但是在递归调用函数处，要使用 if self.concrol_car(...)=='death_lock:
return 'death_lock' 语句的形式，这样才能从多层调用中返回死锁标志，否则调度出现错误。

5、输入文件为赛题给出的car.txt、cross.txt、road.txt以及其他路径规划算法得到的每辆车的路径信息，我们将其中一个路径文件保存为了path.npy文件，方便本程序读取。

6、本代码具体使用方法可见main.py代码中的注释，也希望大家能够多多交流与讨论。
